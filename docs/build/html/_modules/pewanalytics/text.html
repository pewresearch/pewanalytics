
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>pewanalytics.text &#8212; pewanalytics 0.0.1 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for pewanalytics.text</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">sp</span>

<span class="kn">from</span> <span class="nn">sklearn.feature_extraction.text</span> <span class="k">import</span> <span class="n">TfidfVectorizer</span><span class="p">,</span> <span class="n">CountVectorizer</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics.pairwise</span> <span class="k">import</span> <span class="n">cosine_similarity</span>

<span class="kn">import</span> <span class="nn">nltk</span>
<span class="kn">from</span> <span class="nn">nltk.corpus</span> <span class="k">import</span> <span class="n">wordnet</span>

<span class="kn">from</span> <span class="nn">tqdm</span> <span class="k">import</span> <span class="n">tqdm</span>
<span class="kn">from</span> <span class="nn">stopit</span> <span class="k">import</span> <span class="n">ThreadingTimeout</span> <span class="k">as</span> <span class="n">Timeout</span>
<span class="kn">from</span> <span class="nn">fuzzywuzzy</span> <span class="k">import</span> <span class="n">fuzz</span>
<span class="kn">from</span> <span class="nn">difflib</span> <span class="k">import</span> <span class="n">SequenceMatcher</span>
<span class="kn">from</span> <span class="nn">stopit</span> <span class="k">import</span> <span class="n">TimeoutException</span>

<span class="kn">from</span> <span class="nn">pewtils</span> <span class="k">import</span> <span class="n">is_null</span><span class="p">,</span> <span class="n">is_not_null</span>
<span class="kn">from</span> <span class="nn">pewtils.http</span> <span class="k">import</span> <span class="n">strip_html</span>
<span class="kn">from</span> <span class="nn">pewtils</span> <span class="k">import</span> <span class="n">decode_text</span> <span class="k">as</span> <span class="n">_decode_text</span>
<span class="kn">from</span> <span class="nn">pewtils.regex</span> <span class="k">import</span> <span class="n">URL_REGEX</span>

<span class="kn">from</span> <span class="nn">pewanalytics.stats.clustering</span> <span class="k">import</span> <span class="n">compute_hdbscan_clusters</span><span class="p">,</span> <span class="n">compute_kmeans_clusters</span>
<span class="kn">from</span> <span class="nn">pewanalytics.stats.mutual_info</span> <span class="k">import</span> <span class="n">compute_mutual_info</span>
<span class="kn">from</span> <span class="nn">pewanalytics.stats.dimensionality_reduction</span> <span class="k">import</span> <span class="n">get_lsa</span><span class="p">,</span> <span class="n">get_pca</span>



<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">.. _text:</span>

<span class="sd">.. tip: Insert tip</span>

<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: _autosummary</span>
<span class="sd">    :template: clean.rst</span>

<span class="sd">    dates</span>
<span class="sd">    fragments</span>
<span class="sd">    ner</span>
<span class="sd">    topics</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="has_fragment"><a class="viewcode-back" href="../../text.html#pewanalytics.text.has_fragment">[docs]</a><span class="k">def</span> <span class="nf">has_fragment</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">fragment</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param text: The text to search</span>
<span class="sd">    :param fragment: The fragment to search for</span>
<span class="sd">    :return: Whether or not the text contains the fragment</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">([</span>
        <span class="p">(</span><span class="n">fragment</span> <span class="ow">in</span> <span class="n">text</span><span class="p">),</span>
        <span class="p">(</span><span class="n">_decode_text</span><span class="p">(</span><span class="n">fragment</span><span class="p">)</span> <span class="ow">in</span> <span class="n">_decode_text</span><span class="p">(</span><span class="n">text</span><span class="p">))</span>
    <span class="p">]):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="remove_fragments"><a class="viewcode-back" href="../../text.html#pewanalytics.text.remove_fragments">[docs]</a><span class="k">def</span> <span class="nf">remove_fragments</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">fragments</span><span class="p">,</span> <span class="n">throw_loud_fail</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Iteratively remove fragments from a string</span>
<span class="sd">    :param text: string</span>
<span class="sd">    :param fragments: A list of string fragments to search for and remove</span>
<span class="sd">    :return: The original string, minus any parts that matched the fragments provided</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fragments</span><span class="p">:</span>
        <span class="n">new_text</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="c1">#if the new text is the same as previous, try decoding</span>
        <span class="k">if</span> <span class="n">new_text</span> <span class="o">==</span> <span class="n">text</span><span class="p">:</span>
            <span class="n">new_text</span> <span class="o">=</span> <span class="n">_decode_text</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">throw_loud_fail</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">_decode_text</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">throw_loud_fail</span><span class="p">),</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="c1">#if the new text is still the same as previous, then new text is None</span>
        <span class="k">if</span> <span class="n">new_text</span> <span class="o">==</span> <span class="n">text</span><span class="p">:</span>
            <span class="n">new_text</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">new_text</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">new_text</span>
    <span class="k">return</span> <span class="n">text</span></div>

<div class="viewcode-block" id="filter_parts_of_speech"><a class="viewcode-back" href="../../text.html#pewanalytics.text.filter_parts_of_speech">[docs]</a><span class="k">def</span> <span class="nf">filter_parts_of_speech</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">filter_pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exclude</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retain words associated with parts of speech in the text if exclude = False.</span>
<span class="sd">    If exclude = True, exclude words associated with parts of speech.</span>
<span class="sd">    Default is Noun (NN), Proper Noun (NNP) and Adjective (JJ)</span>

<span class="sd">    :param text: string</span>
<span class="sd">    :param filter_pos: array of part of speech tags (default is &#39;NN&#39;, &#39;NNP&#39;, and &#39;JJ&#39;)</span>
<span class="sd">        the options here are: CD, VBN, VBG, RB</span>
<span class="sd">        Note: the full list of POS is here: https://www.ling.upenn.edu/courses/Fall_2003/ling001/penn_treebank_pos.html</span>

<span class="sd">    :return: cleaned string</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">filter_pos</span><span class="p">:</span>
        <span class="n">filter_pos</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;NN&#39;</span><span class="p">,</span><span class="s1">&#39;NNP&#39;</span><span class="p">,</span><span class="s1">&#39;JJ&#39;</span><span class="p">)</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="n">tagged_words</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">pos_tag</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">exclude</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="p">[</span><span class="n">word</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">tagged_words</span> <span class="k">if</span> <span class="n">word</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">filter_pos</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="p">[</span><span class="n">word</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">tagged_words</span> <span class="k">if</span> <span class="n">word</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">filter_pos</span><span class="p">]</span>
    <span class="k">return</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">valid</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_fuzzy_ratio"><a class="viewcode-back" href="../../text.html#pewanalytics.text.get_fuzzy_ratio">[docs]</a><span class="k">def</span> <span class="nf">get_fuzzy_ratio</span><span class="p">(</span><span class="n">text1</span><span class="p">,</span> <span class="n">text2</span><span class="p">,</span> <span class="n">throw_loud_fail</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Uses Levenshtein Distance to calculate similarity of two strings.  Measures how the edit distance compares \</span>
<span class="sd">    to the overall length of the texts.</span>

<span class="sd">    :param text1: First string</span>
<span class="sd">    :param text2: Second string</span>
<span class="sd">    :param throw_loud_fail: bool; does not remove all remove nonascii characters if false</span>
<span class="sd">    :return: The Levenshtein ratio between the two texts</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fuzz</span><span class="o">.</span><span class="n">ratio</span><span class="p">(</span><span class="n">text1</span><span class="p">,</span> <span class="n">text2</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">UnicodeDecodeError</span><span class="p">,</span> <span class="ne">UnicodeEncodeError</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">fuzz</span><span class="o">.</span><span class="n">ratio</span><span class="p">(</span><span class="n">_decode_text</span><span class="p">(</span><span class="n">text1</span><span class="p">,</span> <span class="n">throw_loud_fail</span><span class="p">),</span> <span class="n">_decode_text</span><span class="p">(</span><span class="n">text2</span><span class="p">,</span> <span class="n">throw_loud_fail</span><span class="p">))</span></div>


<div class="viewcode-block" id="get_fuzzy_partial_ratio"><a class="viewcode-back" href="../../text.html#pewanalytics.text.get_fuzzy_partial_ratio">[docs]</a><span class="k">def</span> <span class="nf">get_fuzzy_partial_ratio</span><span class="p">(</span><span class="n">text1</span><span class="p">,</span> <span class="n">text2</span><span class="p">,</span> <span class="n">throw_loud_fail</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Useful to calculate similarity of two strings that are of noticeably different lengths.  Allows for the possibility \</span>
<span class="sd">    that one text is a subset of the other; finds the largest overlap and computes the Levenshtein ratio on that.</span>


<span class="sd">    :param text1: First string</span>
<span class="sd">    :param text2: Second string</span>
<span class="sd">    :param timeout: The number of seconds to wait before giving up</span>
<span class="sd">    :param throw_loud_fail: bool; does not remove all remove nonascii characters if false</span>
<span class="sd">    :return: The partial Levenshtein ratio between the two texts</span>

<span class="sd">    :accepts kwarg timeout:</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">partial_ratio</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">with</span> <span class="n">Timeout</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span> <span class="n">swallow_exc</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">partial_ratio</span> <span class="o">=</span> <span class="n">fuzz</span><span class="o">.</span><span class="n">partial_ratio</span><span class="p">(</span><span class="n">text1</span><span class="p">,</span> <span class="n">text2</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">UnicodeDecodeError</span><span class="p">,</span> <span class="ne">UnicodeEncodeError</span><span class="p">):</span>
            <span class="n">partial_ratio</span> <span class="o">=</span> <span class="n">fuzz</span><span class="o">.</span><span class="n">partial_ratio</span><span class="p">(</span><span class="n">_decode_text</span><span class="p">(</span><span class="n">text1</span><span class="p">,</span> <span class="n">throw_loud_fail</span><span class="p">),</span> <span class="n">_decode_text</span><span class="p">(</span><span class="n">text2</span><span class="p">,</span> <span class="n">throw_loud_fail</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">partial_ratio</span></div>


<div class="viewcode-block" id="SentenceTokenizer"><a class="viewcode-back" href="../../text.html#pewanalytics.text.SentenceTokenizer">[docs]</a><span class="k">class</span> <span class="nc">SentenceTokenizer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initializes a tokenizer that can be be used to break text into tokens using the `tokenize` function</span>

<span class="sd">    :param base_tokenizer: The tokenizer to use (default = NLTK&#39;s English Punkt tokenizer)</span>
<span class="sd">    :param regex_split_trailing: A compiled regex object used to define the end of sentences</span>
<span class="sd">    :param regex_split_leading: A compiled regex object used to define the beginning of sentences</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_tokenizer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">regex_split_trailing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">regex_split_leading</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">base_tokenizer</span> <span class="o">=</span> <span class="n">base_tokenizer</span> <span class="k">if</span> <span class="n">base_tokenizer</span> <span class="k">else</span> <span class="n">nltk</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;tokenizers/punkt/english.pickle&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regex_split_trailing</span> <span class="o">=</span> <span class="n">regex_split_trailing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regex_split_leading</span> <span class="o">=</span> <span class="n">regex_split_leading</span>

<div class="viewcode-block" id="SentenceTokenizer.tokenize"><a class="viewcode-back" href="../../text.html#pewanalytics.text.SentenceTokenizer.tokenize">[docs]</a>    <span class="k">def</span> <span class="nf">tokenize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">throw_loud_fail</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">min_length</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param text: The text to tokenize</span>
<span class="sd">        :param throw_loud_fail: bool; does not remove all remove nonascii characters if false</span>
<span class="sd">        :param min_length: The minimum acceptable length of a sentence \</span>
<span class="sd">            (if a token is shorter than this, it will be considered part of the preceding sentence)</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">text</span> <span class="o">=</span> <span class="n">_decode_text</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">throw_loud_fail</span><span class="p">)</span>

        <span class="n">partial_tokens</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">token_group</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_tokenizer</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">regex_split_leading</span><span class="p">:</span>
                <span class="n">partial_tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">leaders</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">regex_split_leading</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="n">token_group</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">subt_lead</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">regex_split_leading</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">subt_lead</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                        <span class="n">token_group</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subt_lead</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">leaders</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">subt_lead</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">leaders</span><span class="p">:</span>
                        <span class="n">partial_tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">token_group</span><span class="p">))</span>
                        <span class="n">token_group</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">token_group</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">partial_tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">token_group</span> <span class="k">if</span> <span class="n">t</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">]))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">token_group</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">partial_tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">token_group</span> <span class="k">if</span> <span class="n">t</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">]))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">regex_split_trailing</span><span class="p">:</span>
            <span class="n">final_tokens</span> <span class="o">=</span> <span class="n">partial_tokens</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">final_tokens</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">token_group</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">partial_tokens</span><span class="p">:</span>
                <span class="n">trailers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">regex_split_trailing</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="n">token_group</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">subt_trail</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">regex_split_trailing</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">subt_trail</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                        <span class="n">token_group</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subt_trail</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">trailers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">subt_trail</span> <span class="ow">in</span> <span class="n">trailers</span><span class="p">:</span>
                        <span class="n">final_tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">token_group</span><span class="p">))</span>
                        <span class="n">token_group</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">token_group</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">final_tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">token_group</span> <span class="k">if</span> <span class="n">t</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">]))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">token_group</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">final_tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">token_group</span> <span class="k">if</span> <span class="n">t</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">]))</span>

        <span class="n">final_tokens</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">final_tokens</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">min_length</span><span class="p">:</span>
            <span class="n">final_tokens</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">final_tokens</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">min_length</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">final_tokens</span></div></div>


<div class="viewcode-block" id="TextOverlapExtractor"><a class="viewcode-back" href="../../text.html#pewanalytics.text.TextOverlapExtractor">[docs]</a><span class="k">class</span> <span class="nc">TextOverlapExtractor</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param tokenizer: The tokenizer to use (default = SentenceTokenizer())</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokenizer</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">tokenizer</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span> <span class="o">=</span> <span class="n">SentenceTokenizer</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span> <span class="o">=</span> <span class="n">tokenizer</span>

<div class="viewcode-block" id="TextOverlapExtractor.get_text_overlaps"><a class="viewcode-back" href="../../text.html#pewanalytics.text.TextOverlapExtractor.get_text_overlaps">[docs]</a>    <span class="k">def</span> <span class="nf">get_text_overlaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text1</span><span class="p">,</span> <span class="n">text2</span><span class="p">,</span> <span class="n">min_length</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">tokenize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param text1: A piece of text</span>
<span class="sd">        :param text2: Another piece of text to compare against the first</span>
<span class="sd">        :param min_length: Minimum length of overlapping text to identify</span>
<span class="sd">        :param tokenize: Whether or not to tokenize the results; \</span>
<span class="sd">        if False, a single block of concatenated text will be returned (default = True)</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">tokenize</span><span class="p">:</span>
            <span class="n">valid_tokens</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="s2">&quot;. &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">text1</span><span class="p">,</span> <span class="n">text2</span><span class="p">]))]</span>
        <span class="n">fragments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">SequenceMatcher</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">text1</span><span class="p">,</span> <span class="n">text2</span><span class="p">,</span> <span class="n">autojunk</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">get_matching_blocks</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">min_length</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">text1</span><span class="p">[</span><span class="n">block</span><span class="o">.</span><span class="n">a</span><span class="p">:(</span><span class="n">block</span><span class="o">.</span><span class="n">a</span> <span class="o">+</span> <span class="n">block</span><span class="o">.</span><span class="n">size</span><span class="p">)],</span> <span class="n">min_length</span><span class="o">=</span><span class="n">min_length</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">min_length</span><span class="p">:</span>
                        <span class="n">token</span> <span class="o">=</span> <span class="n">token</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">tokenize</span> <span class="ow">or</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">valid_tokens</span><span class="p">:</span>
                            <span class="n">fragments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fragments</span></div>

    <span class="k">def</span> <span class="nf">get_largest_overlap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text1</span><span class="p">,</span> <span class="n">text2</span><span class="p">):</span>

        <span class="n">s</span> <span class="o">=</span> <span class="n">SequenceMatcher</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">text1</span><span class="p">,</span> <span class="n">text2</span><span class="p">)</span>
        <span class="n">pos_a</span><span class="p">,</span> <span class="n">pos_b</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">find_longest_match</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">text1</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">text2</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">text1</span><span class="p">[</span><span class="n">pos_a</span><span class="p">:</span><span class="n">pos_a</span> <span class="o">+</span> <span class="n">size</span><span class="p">]</span></div>


<div class="viewcode-block" id="TextCleaner"><a class="viewcode-back" href="../../text.html#pewanalytics.text.TextCleaner">[docs]</a><span class="k">class</span> <span class="nc">TextCleaner</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class for cleaning text up, in preparation for NLP, etc.  Attempts to decode the text.  Then lowercases,</span>
<span class="sd">    expands contractions, removes punctuation, lemmatizes, removes stopwords and words less than three characters,</span>
<span class="sd">    and consolidates whitespace.</span>

<span class="sd">    :param lemmatize: Whether or not to lemmatize the tokens (default = True)</span>
<span class="sd">    :param tokenizer: Tokenizer to use (default = nltk.WhitespaceTokenizer())</span>
<span class="sd">    :param replacers: A list of tuples, each with a regex pattern followed by the string/pattern to replace them with.\</span>
<span class="sd">    Anything passed here will be used in addition to a set of built-in replacement patterns for common contractions.</span>
<span class="sd">    :param lemmatizer: Lemmatizer to use (default = nltk.WordNetLemmatizer())</span>
<span class="sd">    :param stopwords: The set of stopwords to remove (default = nltk.corpus.stopwords.words(&#39;english&#39;))</span>
<span class="sd">    :param lowercase: Whether or not to lowercase the string (default = True)</span>
<span class="sd">    :param remove_urls: Whether or not to remove URLs and links from the text (default = True)</span>
<span class="sd">    :param throw_loud_fail: bool; does not remove all remove nonascii characters if false</span>
<span class="sd">    :param strip_html: Whether or not to remove contents wrapped in HTML tags (default = False)</span>
<span class="sd">    :param filter_pos: A list of WordNet parts-of-speech tags to keep; \</span>
<span class="sd">    if provided, all other words will be removed (default = None)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">throw_loud_fail</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">filter_pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">lemmatize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">lemmatizer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">lowercase</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">remove_urls</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">replacers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">stopwords</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">strip_html</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">tokenizer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span> <span class="o">=</span> <span class="n">tokenizer</span> <span class="k">if</span> <span class="n">tokenizer</span> <span class="k">else</span> <span class="n">nltk</span><span class="o">.</span><span class="n">WhitespaceTokenizer</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replacers</span> <span class="o">=</span> <span class="n">replacers</span> <span class="k">if</span> <span class="n">replacers</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replacers</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
            <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;won\t&#39;</span><span class="p">,</span> <span class="s1">&#39;will_not&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;can\t&#39;</span><span class="p">,</span> <span class="s1">&#39;cannot&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;i</span><span class="se">\&#39;</span><span class="s1">m&#39;</span><span class="p">,</span> <span class="s1">&#39;i am&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;ain</span><span class="se">\&#39;</span><span class="s1">t&#39;</span><span class="p">,</span> <span class="s1">&#39;is not&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\w+)</span><span class="se">\&#39;</span><span class="s1">ll&#39;</span><span class="p">,</span> <span class="s1">&#39;\g&lt;1&gt; will&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\w+)n</span><span class="se">\&#39;</span><span class="s1">t&#39;</span><span class="p">,</span> <span class="s1">&#39;\g&lt;1&gt; not&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\w+)</span><span class="se">\&#39;</span><span class="s1">ve&#39;</span><span class="p">,</span> <span class="s1">&#39;\g&lt;1&gt; have&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\w+)</span><span class="se">\&#39;</span><span class="s1">re&#39;</span><span class="p">,</span> <span class="s1">&#39;\g&lt;1&gt; are&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\w+)</span><span class="se">\&#39;</span><span class="s1">d&#39;</span><span class="p">,</span> <span class="s1">&#39;\g&lt;1&gt; would&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;it</span><span class="se">\&#39;</span><span class="s1">s&#39;</span><span class="p">,</span> <span class="s1">&#39;it is&#39;</span><span class="p">)</span>
        <span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replacers</span> <span class="o">=</span> <span class="p">[(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\b(</span><span class="si">{}</span><span class="s2">)\b&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">regex</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="n">regex</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">regex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">replacers</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">lemmatize</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lemmatizer</span> <span class="o">=</span> <span class="n">lemmatizer</span> <span class="k">if</span> <span class="n">lemmatizer</span> <span class="k">else</span> <span class="n">nltk</span><span class="o">.</span><span class="n">WordNetLemmatizer</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lemmatizer</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">stopwords</span><span class="p">:</span>
            <span class="n">stopwords</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">nltk</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">stopwords</span><span class="o">.</span><span class="n">words</span><span class="p">(</span><span class="s1">&#39;english&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stopword_regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\b(</span><span class="si">{}</span><span class="s2">)\b&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="sa">r</span><span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stopwords</span> <span class="k">if</span> <span class="n">s</span><span class="p">])</span>
            <span class="p">),</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">remove_urls</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">url_regex</span> <span class="o">=</span> <span class="n">URL_REGEX</span>
<span class="c1">#            self.url_regex = re.compile(</span>
<span class="c1">#                r&quot;((https?:\/\/(www\.)?)?[-a-zA-Z0-9@:%._\+~#=]{2,4000}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&amp;//=]*))&quot;</span>
<span class="c1">#            )</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">url_regex</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">filter_pos</span> <span class="o">=</span> <span class="n">filter_pos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lowercase</span> <span class="o">=</span> <span class="n">lowercase</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">throw_loud_fail</span> <span class="o">=</span> <span class="n">throw_loud_fail</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strip_html</span> <span class="o">=</span> <span class="n">strip_html</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final_regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\w*\d\w*&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="TextCleaner.clean"><a class="viewcode-back" href="../../text.html#pewanalytics.text.TextCleaner.clean">[docs]</a>    <span class="k">def</span> <span class="nf">clean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param string: The string to clean</span>
<span class="sd">        :return: The cleaned string</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># try to remove any html tags in the string</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strip_html</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">strip_html</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

        <span class="c1"># try to encode everything as utf-8</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">_decode_text</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">throw_loud_fail</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_pos</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">filter_parts_of_speech</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_pos</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lowercase</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">text</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">url_regex</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">url_regex</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">regex</span><span class="p">,</span> <span class="n">replace</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">replacers</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">regex</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">replace</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span> <span class="c1"># expand contractions</span>
        <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stopword_regex</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\W+&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>  <span class="c1"># remove punctuation</span>
        <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>  <span class="c1"># split on whitespace</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lemmatizer</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">lemmatizer</span><span class="o">.</span><span class="n">lemmatize</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">text</span><span class="p">]</span>

        <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">word</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">text</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lemmatizer</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stopword_regex</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\W+&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>

        <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_regex</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">text</span></div></div>


<div class="viewcode-block" id="TextDataFrame"><a class="viewcode-back" href="../../text.html#pewanalytics.text.TextDataFrame">[docs]</a><span class="k">class</span> <span class="nc">TextDataFrame</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param df: A dataframe of documents.  Must contain a column with text.</span>
<span class="sd">    :param text_column: The name of the column in the dataframe that contains the text</span>
<span class="sd">    :param min_frequency: The minimum number of documents a word must be found in for it to be used in \</span>
<span class="sd">        document comparisons (default = 1)</span>
<span class="sd">    :param vectorizer_kwargs: All remaining keyword arguments are passed to TfidfVectorizer</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">text_column</span><span class="p">,</span> <span class="n">min_frequency</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">vectorizer_kwargs</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span> <span class="o">=</span> <span class="n">df</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">text_column</span> <span class="o">=</span> <span class="n">text_column</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vectorizer</span> <span class="o">=</span> <span class="n">TfidfVectorizer</span><span class="p">(</span>
            <span class="n">min_df</span><span class="o">=</span><span class="n">min_frequency</span><span class="p">,</span>
            <span class="n">decode_error</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span>
            <span class="o">**</span><span class="n">vectorizer_kwargs</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tfidf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vectorizer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">text_column</span><span class="p">])</span>


<div class="viewcode-block" id="TextDataFrame.search_corpus"><a class="viewcode-back" href="../../text.html#pewanalytics.text.TextDataFrame.search_corpus">[docs]</a>    <span class="k">def</span> <span class="nf">search_corpus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compares the provided text against the documents in the corpus and returns the most similar documents. \</span>
<span class="sd">        A new column called &#39;cosine_similarity&#39; is generated, which is used to sort and return the dataframe.</span>

<span class="sd">        :param text: The text to compare documents against</span>
<span class="sd">        :return: The corpus dataframe sorted by cosine similarity</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">similarities</span> <span class="o">=</span> <span class="n">cosine_similarity</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vectorizer</span><span class="o">.</span><span class="n">transform</span><span class="p">([</span><span class="n">text</span><span class="p">]),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tfidf</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">[</span><span class="s1">&#39;search_cosine_similarity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">similarities</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;search_cosine_similarity&quot;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="TextDataFrame.match_text_to_corpus"><a class="viewcode-back" href="../../text.html#pewanalytics.text.TextDataFrame.match_text_to_corpus">[docs]</a>    <span class="k">def</span> <span class="nf">match_text_to_corpus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">match_list</span><span class="p">,</span> <span class="n">allow_multiple</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">min_similarity</span><span class="o">=.</span><span class="mi">9</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param match_list: A list of strings (other documents) to be matched to documents in the dataframe</span>
<span class="sd">        :param allow_multiple: If set to True and your corpus contains duplicates, they will all be matched to \</span>
<span class="sd">        their best match in match_list.  If False (default), only the first row will be matched.</span>
<span class="sd">        :param min_similarity: Minimum cosine similarity required for any match to be made.</span>
<span class="sd">        :return: Your corpus dataframe, with new columns match_text, match_index, and cosine_similarity</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">similarities</span> <span class="o">=</span> <span class="n">cosine_similarity</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tfidf</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vectorizer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">match_list</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">[</span><span class="s2">&quot;match_text&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">[</span><span class="s2">&quot;match_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">[</span><span class="s2">&quot;cosine_similarity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">iterrows</span><span class="p">(),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Matching items to corpus&quot;</span><span class="p">):</span>
            <span class="n">row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">is_null</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;match_index&quot;</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sim</span> <span class="ow">in</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span>
                               <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">match_list</span><span class="p">))),</span> <span class="n">similarities</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">index</span><span class="p">)]),</span>
                                      <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">min_similarity</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">[</span><span class="s2">&quot;match_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">allow_multiple</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">text_column</span><span class="p">]</span> <span class="o">==</span> <span class="n">row</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">text_column</span><span class="p">],</span> <span class="s1">&#39;match_index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">text_column</span><span class="p">]</span> <span class="o">==</span> <span class="n">row</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">text_column</span><span class="p">],</span> <span class="s1">&#39;match_text&#39;</span><span class="p">]</span> <span class="o">=</span> \
                            <span class="n">match_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">text_column</span><span class="p">]</span> <span class="o">==</span> <span class="n">row</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">text_column</span><span class="p">],</span> <span class="s2">&quot;cosine_similarity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sim</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;match_index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;match_text&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">match_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="s2">&quot;cosine_similarity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sim</span>
                        <span class="k">break</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span></div>


<div class="viewcode-block" id="TextDataFrame.extract_corpus_fragments"><a class="viewcode-back" href="../../text.html#pewanalytics.text.TextDataFrame.extract_corpus_fragments">[docs]</a>    <span class="k">def</span> <span class="nf">extract_corpus_fragments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scan_top_n_matches_per_doc</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">min_fragment_length</span><span class="o">=</span><span class="mi">15</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over the corpus dataframe and, for each document, scan the most similar other documents in the corpus. \</span>
<span class="sd">        During each comparison, overlapping fragments are identified.  This can be useful for identifying common \</span>
<span class="sd">        boilerplate sentences, repeated paragraphs, etc.</span>

<span class="sd">        :param scan_top_n_matches_per_doc: The number of other documents to compare each document against.</span>
<span class="sd">        :param min_fragment_length: The minimum character length a fragment must have to be extracted.</span>
<span class="sd">        :return: A list of fragments that were found.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">text_overlap_extractor</span> <span class="o">=</span> <span class="n">TextOverlapExtractor</span><span class="p">()</span>

        <span class="n">similarity_matrix</span> <span class="o">=</span> <span class="n">cosine_similarity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tfidf</span><span class="p">)</span>
        <span class="n">min_similarity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">similarity_matrix</span><span class="p">])</span>

        <span class="n">combos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">index</span><span class="p">)):</span>
            <span class="n">combos</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="p">[(</span><span class="n">i</span><span class="p">,</span>  <span class="n">cos_similarity</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">cos_similarity</span> <span class="ow">in</span>
                 <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">index</span><span class="p">))),</span> <span class="n">similarity_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                 <span class="k">if</span>  <span class="n">cos_similarity</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">.</span><span class="mi">997</span> <span class="ow">and</span>  <span class="n">cos_similarity</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">min_similarity</span>
                 <span class="p">][:</span><span class="n">scan_top_n_matches_per_doc</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="n">fragments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span>  <span class="n">cos_similarity</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">combos</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Extracting fragments&quot;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">frag</span> <span class="ow">in</span> <span class="n">text_overlap_extractor</span><span class="o">.</span><span class="n">get_text_overlaps</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">text_column</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span> <span class="n">cos_similarity</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">text_column</span><span class="p">],</span>
                    <span class="n">min_length</span><span class="o">=</span><span class="n">min_fragment_length</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="n">frag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fragments</span><span class="p">:</span>
                    <span class="n">fragments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frag</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fragments</span></div>

<div class="viewcode-block" id="TextDataFrame.find_duplicates"><a class="viewcode-back" href="../../text.html#pewanalytics.text.TextDataFrame.find_duplicates">[docs]</a>    <span class="k">def</span> <span class="nf">find_duplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tfidf_threshold</span><span class="o">=.</span><span class="mi">9</span><span class="p">,</span> <span class="n">fuzzy_ratio_threshold</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span> <span class="n">allow_partial</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">max_partial_difference</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">filter_function</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">partial_ratio_timeout</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">decode_text</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Search for duplicates by using cosine similarity and Levenshtein ratios.  This will struggle with large \</span>
<span class="sd">        corpora, so we recommend trying to filter down to potential duplicates first.  The corpus will first be \</span>
<span class="sd">        scanned for document pairs with a cosine similarity greater or equal to the `tfidf_threshold`.  Then, \</span>
<span class="sd">        each of these pairs will be compared using the more stringent `fuzzy_ratio_threshold`.</span>

<span class="sd">        :param tfidf_threshold: Minimum cosine similarity for two documents to be considered potential dupes.</span>
<span class="sd">        :param fuzzy_ratio_threshold: The required Levenshtein ratio to consider two documents duplicates.</span>
<span class="sd">        :param filter_function: An optional function that allows for more complex filtering.  The function must accept \</span>
<span class="sd">        the following parameters: text1, text2, cosine_similarity, fuzzy_ratio.  Must return True or False, indicating \</span>
<span class="sd">        whether the two documents should be considered duplicates.</span>
<span class="sd">        :return: A list of lists, containing groups of duplicate documents \</span>
<span class="sd">        (represented as rows from the corpus dataframe)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">text_column</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">decode_text</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">_decode_text</span><span class="p">)</span>

        <span class="n">groups</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1">#compute cosine similarity between the inputs in tf.idf matrix</span>
        <span class="n">similarity_matrix</span> <span class="o">=</span> <span class="n">cosine_similarity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tfidf</span><span class="p">)</span>
        <span class="n">threshold_filter_matrix</span> <span class="o">=</span> <span class="n">similarity_matrix</span> <span class="o">&gt;=</span> <span class="n">tfidf_threshold</span>

        <span class="c1">#return the  location of the similarity matrix that satisfies the threshold</span>
        <span class="n">similarity_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">threshold_filter_matrix</span><span class="p">,</span> <span class="n">similarity_matrix</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1">#create pairs in the similarity matrix</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">similarity_matrix</span><span class="p">)</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">pairs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">similarity_matrix</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pairs</span> <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">pairs</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Scanning pairs&quot;</span><span class="p">):</span>
            <span class="n">sim</span> <span class="o">=</span> <span class="n">similarity_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
            <span class="n">ratio</span> <span class="o">=</span> <span class="n">get_fuzzy_ratio</span><span class="p">(</span><span class="n">text</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">text</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">ratio</span> <span class="o">&lt;</span> <span class="n">fuzzy_ratio_threshold</span> <span class="ow">and</span> <span class="n">allow_partial</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">partial_ratio</span> <span class="o">=</span> <span class="n">get_fuzzy_partial_ratio</span><span class="p">(</span><span class="n">text</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">text</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                                                            <span class="n">timeout</span><span class="o">=</span><span class="n">partial_ratio_timeout</span><span class="p">)</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">MemoryError</span><span class="p">,</span> <span class="n">TimeoutException</span><span class="p">):</span>
                    <span class="n">partial_ratio</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                    <span class="n">partial_ratio</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">partial_ratio</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ratio</span> <span class="o">-</span> <span class="n">partial_ratio</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">max_partial_difference</span><span class="p">:</span>
                    <span class="n">ratio</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">ratio</span><span class="p">,</span> <span class="n">partial_ratio</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">ratio</span> <span class="o">&gt;=</span> <span class="n">fuzzy_ratio_threshold</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="ow">not</span> <span class="n">filter_function</span> <span class="ow">or</span> <span class="n">filter_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">sim</span><span class="p">,</span> <span class="n">ratio</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">groups</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="ow">and</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">groups</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                    <span class="n">new_group</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
                    <span class="n">groups</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_group</span>
                    <span class="n">groups</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_group</span>
                <span class="k">elif</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">groups</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="ow">and</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">groups</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                    <span class="n">groups</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">groups</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">groups</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="ow">and</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">groups</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                    <span class="n">groups</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">groups</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">groups</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                    <span class="n">groups</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="n">duplicates</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">final_groups</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">groups</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">g</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">final_groups</span><span class="p">:</span>
                <span class="n">final_groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
                <span class="n">duplicates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="p">)])</span>

        <span class="k">return</span> <span class="n">duplicates</span></div>

<div class="viewcode-block" id="TextDataFrame.mutual_info"><a class="viewcode-back" href="../../text.html#pewanalytics.text.TextDataFrame.mutual_info">[docs]</a>    <span class="k">def</span> <span class="nf">mutual_info</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">outcome_col</span><span class="p">,</span>
            <span class="n">weight_col</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">sample_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">sort_by</span><span class="o">=</span><span class="s2">&quot;MI&quot;</span><span class="p">,</span>
            <span class="n">top_n</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span>
            <span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">return_raw</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param outcome_col: The name of the column with the binary outcome variable</span>
<span class="sd">        :param top_n: The number of features for each partition you want to return</span>
<span class="sd">        :param l: An optional Laplace smoothing parameter</span>
<span class="sd">        :param normalize: Toggle normalization on or off (to control for feature prevalance), on by default</span>
<span class="sd">        :param return_raw: Return the raw mutual info dataframe instead of sorting and splitting the results</span>
<span class="sd">        :return:</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">sample_size</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">sample_size</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span>
        <span class="k">if</span> <span class="n">weight_col</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">text_column</span><span class="p">,</span> <span class="n">outcome_col</span><span class="p">,</span> <span class="n">weight_col</span><span class="p">])</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">text_column</span><span class="p">,</span> <span class="n">outcome_col</span><span class="p">])</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">outcome_col</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vectorizer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">text_column</span><span class="p">])</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">weight_col</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">weight_col</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">compute_mutual_info</span><span class="p">(</span>
            <span class="n">y</span><span class="p">,</span>
            <span class="n">x</span><span class="p">,</span>
            <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span>
            <span class="n">col_names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vectorizer</span><span class="o">.</span><span class="n">get_feature_names</span><span class="p">(),</span>
            <span class="n">l</span><span class="o">=</span><span class="n">l</span><span class="p">,</span>
            <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">,</span>
            <span class="n">top_n</span><span class="o">=</span><span class="n">top_n</span><span class="p">,</span>
            <span class="n">sort_by</span><span class="o">=</span><span class="n">sort_by</span><span class="p">,</span>
            <span class="n">return_raw</span><span class="o">=</span><span class="n">return_raw</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">kmeans_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">[</span><span class="s2">&quot;kmeans&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">compute_kmeans_clusters</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tfidf</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">return_score</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;KMeans clusters saved to self.corpus[&#39;kmeans&#39;]&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">hdbscan_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_cluster_size</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">[</span><span class="s2">&quot;hdbscan&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">compute_hdbscan_clusters</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tfidf</span><span class="p">,</span> <span class="n">min_cluster_size</span><span class="o">=</span><span class="n">min_cluster_size</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="n">min_samples</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;HDBSCAN clusters saved to self.corpus[&#39;hdbscan&#39;]&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">top_cluster_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster_col</span><span class="p">,</span> <span class="n">min_size</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">top_n</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>

        <span class="n">dummies</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">get_dummies</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">[</span><span class="n">cluster_col</span><span class="p">],</span> <span class="n">prefix</span><span class="o">=</span><span class="n">cluster_col</span><span class="p">)</span>
        <span class="n">cluster_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">,</span> <span class="n">dummies</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">terms</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">cluster_df</span><span class="p">[</span><span class="n">cluster_col</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">is_not_null</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_df</span><span class="p">[</span><span class="n">cluster_df</span><span class="p">[</span><span class="n">cluster_col</span><span class="p">]</span> <span class="o">==</span> <span class="n">cluster</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="n">min_size</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cluster_col</span><span class="p">,</span> <span class="n">cluster</span><span class="p">)]</span> <span class="o">=</span> <span class="n">cluster_df</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cluster_col</span><span class="p">,</span> <span class="n">cluster</span><span class="p">)]</span>
                <span class="n">minfo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mutual_info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cluster_col</span><span class="p">,</span> <span class="n">cluster</span><span class="p">),</span>
                                         <span class="n">top_n</span><span class="o">=</span><span class="n">top_n</span><span class="p">,</span> <span class="n">return_raw</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cluster_col</span><span class="p">,</span> <span class="n">cluster</span><span class="p">)]</span>
                <span class="n">minfo</span> <span class="o">=</span> <span class="n">minfo</span><span class="p">[</span><span class="n">minfo</span><span class="p">[</span><span class="s2">&quot;MI1&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;MI1&quot;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)[:</span><span class="n">top_n</span><span class="p">]</span>
                <span class="n">terms</span><span class="p">[</span><span class="n">cluster</span><span class="p">]</span> <span class="o">=</span> <span class="n">minfo</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cluster #</span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2"> documents: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">cluster</span><span class="p">,</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">cluster_df</span><span class="p">[</span><span class="n">cluster_df</span><span class="p">[</span><span class="n">cluster_col</span><span class="p">]</span> <span class="o">==</span> <span class="n">cluster</span><span class="p">]),</span>
                    <span class="n">minfo</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>
                <span class="p">))</span>
        <span class="k">return</span> <span class="n">terms</span>

<div class="viewcode-block" id="TextDataFrame.pca_components"><a class="viewcode-back" href="../../text.html#pewanalytics.text.TextDataFrame.pca_components">[docs]</a>    <span class="k">def</span> <span class="nf">pca_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Saves the PCA components to self.corpus as new columns (&#39;pca_1&#39;, &#39;pca_2&#39;, etc.),</span>
<span class="sd">        saves the top component for each document as self.corpus[&#39;pca&#39;], and returns</span>
<span class="sd">        the features-component matrix</span>

<span class="sd">        :param k: Number of dimensions to extract</span>
<span class="sd">        :return: A dataframe of (features x components)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">components</span><span class="p">,</span> <span class="n">documents</span> <span class="o">=</span> <span class="n">get_pca</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tfidf</span><span class="p">,</span> <span class="n">feature_names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vectorizer</span><span class="o">.</span><span class="n">get_feature_names</span><span class="p">(),</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">documents</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">documents</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Top PCA dimensions saved as clusters to self.corpus[&#39;pca&#39;]&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">components</span></div>

<div class="viewcode-block" id="TextDataFrame.lsa_components"><a class="viewcode-back" href="../../text.html#pewanalytics.text.TextDataFrame.lsa_components">[docs]</a>    <span class="k">def</span> <span class="nf">lsa_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Saves the LSA components to self.corpus as new columns (&#39;lsa_1&#39;, &#39;lsa_2&#39;, etc.),</span>
<span class="sd">        saves the top component for each document as self.corpus[&#39;lsa&#39;], and returns</span>
<span class="sd">        the features-component matrix</span>

<span class="sd">        :param k: Number of dimensions to extract</span>
<span class="sd">        :return: A dataframe of (features x components)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">components</span><span class="p">,</span> <span class="n">documents</span> <span class="o">=</span> <span class="n">get_lsa</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tfidf</span><span class="p">,</span> <span class="n">feature_names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vectorizer</span><span class="o">.</span><span class="n">get_feature_names</span><span class="p">(),</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">documents</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">documents</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Top LSA dimensions saved as clusters to self.corpus[&#39;lsa&#39;]&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">components</span></div>

<div class="viewcode-block" id="TextDataFrame.get_top_documents"><a class="viewcode-back" href="../../text.html#pewanalytics.text.TextDataFrame.get_top_documents">[docs]</a>    <span class="k">def</span> <span class="nf">get_top_documents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component_prefix</span><span class="o">=</span><span class="s1">&#39;cluster&#39;</span><span class="p">,</span> <span class="n">top_n</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use after running get_pca_components or get_lsa_components</span>

<span class="sd">        :param component_prefix: &#39;lsa&#39; or &#39;pca&#39; (you must first run get_pca_components or get_lsa_components)</span>
<span class="sd">        :param top_n: Number of documents to return for each component</span>
<span class="sd">        :return: A dictionary where keys are the component, and values are the top_n document indices (or text, if text_column is provided) for each component</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">top_docs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">component_prefix</span><span class="p">))]:</span>
            <span class="n">docs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">[</span><span class="n">component_prefix</span><span class="p">]</span> <span class="o">==</span> <span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)[:</span><span class="n">top_n</span><span class="p">]</span>
            <span class="n">top_docs</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">docs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">text_column</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="k">return</span> <span class="n">top_docs</span></div>

<div class="viewcode-block" id="TextDataFrame.make_word_cooccurrence_matrix"><a class="viewcode-back" href="../../text.html#pewanalytics.text.TextDataFrame.make_word_cooccurrence_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">make_word_cooccurrence_matrix</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">min_frequency</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
            <span class="n">max_frequency</span><span class="o">=.</span><span class="mi">5</span>
    <span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use to produce word co-occurrence matrices. Based on a helpful StackOverflow post:</span>
<span class="sd">        https://stackoverflow.com/questions/35562789/how-do-i-calculate-a-word-word-co-occurrence-matrix-with-sklearn</span>
<span class="sd">        :param normalize: If True, will be normalized</span>
<span class="sd">        :param min_frequency: The minimum document frequency required for a term to be included</span>
<span class="sd">        :param max_frequency: The maximum proportion of documents containing a term allowed to include the term</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">text_column</span><span class="p">]</span>
        <span class="n">cv</span> <span class="o">=</span> <span class="n">CountVectorizer</span><span class="p">(</span>
            <span class="n">ngram_range</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>
            <span class="n">stop_words</span> <span class="o">=</span> <span class="s1">&#39;english&#39;</span><span class="p">,</span>
            <span class="n">min_df</span><span class="o">=</span><span class="n">min_frequency</span><span class="p">,</span>
            <span class="n">max_df</span><span class="o">=</span><span class="n">max_frequency</span>
        <span class="p">)</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="n">mat</span><span class="p">[</span><span class="n">mat</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># this makes sure that we&#39;re counting number of documents words have in common \</span>
        <span class="c1"># and not weighting by the frequency of one of the words in a single document, which can lead to spurious links</span>
        <span class="n">names</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">get_feature_names</span><span class="p">()</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">mat</span><span class="p">)</span>  <span class="c1"># compute the document-document matrix</span>
        <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
            <span class="n">diag</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">mat</span><span class="o">.</span><span class="n">diagonal</span><span class="p">())</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">diag</span> <span class="o">*</span> <span class="n">mat</span>
        <span class="n">mat</span><span class="o">.</span><span class="n">setdiag</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">mat</span><span class="o">.</span><span class="n">todense</span><span class="p">(),</span> <span class="n">columns</span><span class="o">=</span><span class="n">names</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">names</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">matrix</span></div>

<div class="viewcode-block" id="TextDataFrame.make_document_cooccurrence_matrix"><a class="viewcode-back" href="../../text.html#pewanalytics.text.TextDataFrame.make_document_cooccurrence_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">make_document_cooccurrence_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use to produce document co-occurrence matrices. Based on a helpful StackOverflow post:</span>
<span class="sd">        https://stackoverflow.com/questions/35562789/how-do-i-calculate-a-word-word-co-occurrence-matrix-with-sklearn</span>
<span class="sd">        :param normalize: If True, will be normalized</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">text_column</span><span class="p">]</span>
        <span class="n">cv</span> <span class="o">=</span> <span class="n">CountVectorizer</span><span class="p">(</span><span class="n">ngram_range</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">stop_words</span><span class="o">=</span><span class="s1">&#39;english&#39;</span><span class="p">)</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="n">mat</span><span class="p">[</span><span class="n">mat</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># this makes sure that we&#39;re counting number of words documents have in common \</span>
        <span class="c1"># and not weighting by the frequency of one of the words in a single document, which can lead to spurious links</span>
        <span class="n">names</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">index</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="p">(</span><span class="n">mat</span> <span class="o">*</span> <span class="n">mat</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>  <span class="c1"># compute the word-word matrix</span>
        <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
            <span class="n">diag</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">mat</span><span class="o">.</span><span class="n">diagonal</span><span class="p">())</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">diag</span> <span class="o">*</span> <span class="n">mat</span>
        <span class="n">mat</span><span class="o">.</span><span class="n">setdiag</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">mat</span><span class="o">.</span><span class="n">todense</span><span class="p">(),</span> <span class="n">columns</span><span class="o">=</span><span class="n">names</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">names</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">matrix</span></div></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">pewanalytics</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Navigation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../text.html">Text</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stats.html">Stats</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Pew Research Center.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>