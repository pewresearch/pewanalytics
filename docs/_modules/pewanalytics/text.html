
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>pewanalytics.text &#8212; pewanalytics 0.0.1 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for pewanalytics.text</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span>

<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">sp</span>

<span class="kn">from</span> <span class="nn">sklearn.feature_extraction.text</span> <span class="kn">import</span> <span class="n">TfidfVectorizer</span><span class="p">,</span> <span class="n">CountVectorizer</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics.pairwise</span> <span class="kn">import</span> <span class="n">cosine_similarity</span>

<span class="kn">import</span> <span class="nn">nltk</span>
<span class="kn">from</span> <span class="nn">nltk.corpus</span> <span class="kn">import</span> <span class="n">wordnet</span>

<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">from</span> <span class="nn">stopit</span> <span class="kn">import</span> <span class="n">ThreadingTimeout</span> <span class="k">as</span> <span class="n">Timeout</span>
<span class="kn">from</span> <span class="nn">fuzzywuzzy</span> <span class="kn">import</span> <span class="n">fuzz</span>
<span class="kn">from</span> <span class="nn">difflib</span> <span class="kn">import</span> <span class="n">SequenceMatcher</span>
<span class="kn">from</span> <span class="nn">stopit</span> <span class="kn">import</span> <span class="n">TimeoutException</span>

<span class="kn">from</span> <span class="nn">pewtils</span> <span class="kn">import</span> <span class="n">is_null</span><span class="p">,</span> <span class="n">is_not_null</span>
<span class="kn">from</span> <span class="nn">pewtils.http</span> <span class="kn">import</span> <span class="n">strip_html</span>
<span class="kn">from</span> <span class="nn">pewtils</span> <span class="kn">import</span> <span class="n">decode_text</span> <span class="k">as</span> <span class="n">_decode_text</span>
<span class="kn">from</span> <span class="nn">pewtils.regex</span> <span class="kn">import</span> <span class="n">URL_REGEX</span>

<span class="kn">from</span> <span class="nn">pewanalytics.stats.clustering</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">compute_hdbscan_clusters</span><span class="p">,</span>
    <span class="n">compute_kmeans_clusters</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pewanalytics.stats.mutual_info</span> <span class="kn">import</span> <span class="n">compute_mutual_info</span>
<span class="kn">from</span> <span class="nn">pewanalytics.stats.dimensionality_reduction</span> <span class="kn">import</span> <span class="n">get_lsa</span><span class="p">,</span> <span class="n">get_pca</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">.. _text:</span>

<span class="sd">.. tip: Insert tip</span>

<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: _autosummary</span>
<span class="sd">    :template: clean.rst</span>

<span class="sd">    dates</span>
<span class="sd">    fragments</span>
<span class="sd">    ner</span>
<span class="sd">    topics</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="has_fragment"><a class="viewcode-back" href="../../text.html#pewanalytics.text.has_fragment">[docs]</a><span class="k">def</span> <span class="nf">has_fragment</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">fragment</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks whether a substring (&quot;fragment&quot;) is contained within a larger string (&quot;text&quot;). Uses the `pewtils.decode_text`</span>
<span class="sd">    function to process both the text and the fragment when running this check.</span>

<span class="sd">    :param text: The text to search</span>
<span class="sd">    :param fragment: The fragment to search for</span>
<span class="sd">    :return: Whether or not the text contains the fragment</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">([(</span><span class="n">fragment</span> <span class="ow">in</span> <span class="n">text</span><span class="p">),</span> <span class="p">(</span><span class="n">_decode_text</span><span class="p">(</span><span class="n">fragment</span><span class="p">)</span> <span class="ow">in</span> <span class="n">_decode_text</span><span class="p">(</span><span class="n">text</span><span class="p">))]):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="remove_fragments"><a class="viewcode-back" href="../../text.html#pewanalytics.text.remove_fragments">[docs]</a><span class="k">def</span> <span class="nf">remove_fragments</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">fragments</span><span class="p">,</span> <span class="n">throw_loud_fail</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Iteratively remove fragments from a string</span>

<span class="sd">    :param text: string</span>
<span class="sd">    :param fragments: A list of string fragments to search for and remove</span>
<span class="sd">    :param throw_loud_fail: bool; whether or not to raise an error if text decoding fails (default=False)</span>
<span class="sd">    :return: The original string, minus any parts that matched the fragments provided</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fragments</span><span class="p">:</span>
        <span class="n">new_text</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="c1"># if the new text is the same as previous, try decoding</span>
        <span class="k">if</span> <span class="n">new_text</span> <span class="o">==</span> <span class="n">text</span><span class="p">:</span>
            <span class="n">new_text</span> <span class="o">=</span> <span class="n">_decode_text</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">throw_loud_fail</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                <span class="n">_decode_text</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">throw_loud_fail</span><span class="p">),</span> <span class="s2">&quot;&quot;</span>
            <span class="p">)</span>
        <span class="c1"># if the new text is still the same as previous, then new text is None</span>
        <span class="k">if</span> <span class="n">new_text</span> <span class="o">==</span> <span class="n">text</span><span class="p">:</span>
            <span class="n">new_text</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">new_text</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">new_text</span>
    <span class="k">return</span> <span class="n">text</span></div>


<div class="viewcode-block" id="filter_parts_of_speech"><a class="viewcode-back" href="../../text.html#pewanalytics.text.filter_parts_of_speech">[docs]</a><span class="k">def</span> <span class="nf">filter_parts_of_speech</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">filter_pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retain words associated with parts of speech in the text if exclude = False.</span>
<span class="sd">    If exclude = True, exclude words associated with parts of speech.</span>
<span class="sd">    Default is Noun (NN), Proper Noun (NNP) and Adjective (JJ)</span>

<span class="sd">    :param text: string</span>
<span class="sd">    :param filter_pos: array of part of speech tags (default is &#39;NN&#39;, &#39;NNP&#39;, and &#39;JJ&#39;)</span>
<span class="sd">    The full list of POS is here: https://www.ling.upenn.edu/courses/Fall_2003/ling001/penn_treebank_pos.html</span>

<span class="sd">    :return: A string comprised solely of words that matched to the specified parts of speech</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">filter_pos</span><span class="p">:</span>
        <span class="n">filter_pos</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;NN&quot;</span><span class="p">,</span> <span class="s2">&quot;NNP&quot;</span><span class="p">,</span> <span class="s2">&quot;JJ&quot;</span><span class="p">)</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="n">tagged_words</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">pos_tag</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">exclude</span><span class="p">:</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="p">[</span><span class="n">word</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">tagged_words</span> <span class="k">if</span> <span class="n">word</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">filter_pos</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="p">[</span><span class="n">word</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">tagged_words</span> <span class="k">if</span> <span class="n">word</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">filter_pos</span><span class="p">]</span>
    <span class="k">return</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">valid</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_fuzzy_ratio"><a class="viewcode-back" href="../../text.html#pewanalytics.text.get_fuzzy_ratio">[docs]</a><span class="k">def</span> <span class="nf">get_fuzzy_ratio</span><span class="p">(</span><span class="n">text1</span><span class="p">,</span> <span class="n">text2</span><span class="p">,</span> <span class="n">throw_loud_fail</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Uses Levenshtein Distance to calculate similarity of two strings.  Measures how the edit distance compares</span>
<span class="sd">    to the overall length of the texts.</span>

<span class="sd">    :param text1: First string</span>
<span class="sd">    :param text2: Second string</span>
<span class="sd">    :param throw_loud_fail: bool; whether or not to raise an error if text decoding fails (default=False)</span>
<span class="sd">    :return: The Levenshtein ratio between the two texts</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fuzz</span><span class="o">.</span><span class="n">ratio</span><span class="p">(</span><span class="n">text1</span><span class="p">,</span> <span class="n">text2</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">UnicodeDecodeError</span><span class="p">,</span> <span class="ne">UnicodeEncodeError</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">fuzz</span><span class="o">.</span><span class="n">ratio</span><span class="p">(</span>
            <span class="n">_decode_text</span><span class="p">(</span><span class="n">text1</span><span class="p">,</span> <span class="n">throw_loud_fail</span><span class="p">),</span> <span class="n">_decode_text</span><span class="p">(</span><span class="n">text2</span><span class="p">,</span> <span class="n">throw_loud_fail</span><span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="get_fuzzy_partial_ratio"><a class="viewcode-back" href="../../text.html#pewanalytics.text.get_fuzzy_partial_ratio">[docs]</a><span class="k">def</span> <span class="nf">get_fuzzy_partial_ratio</span><span class="p">(</span><span class="n">text1</span><span class="p">,</span> <span class="n">text2</span><span class="p">,</span> <span class="n">throw_loud_fail</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Useful to calculate similarity of two strings that are of noticeably different lengths.  Allows for the possibility</span>
<span class="sd">    that one text is a subset of the other; finds the largest overlap and computes the Levenshtein ratio on that.</span>

<span class="sd">    :param text1: First string</span>
<span class="sd">    :param text2: Second string</span>
<span class="sd">    :param timeout: The number of seconds to wait before giving up</span>
<span class="sd">    :param throw_loud_fail: bool; whether or not to raise an error if text decoding fails (default=False)</span>
<span class="sd">    :return: The partial Levenshtein ratio between the two texts</span>

<span class="sd">    :accepts kwarg timeout:</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">partial_ratio</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">with</span> <span class="n">Timeout</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span> <span class="n">swallow_exc</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">partial_ratio</span> <span class="o">=</span> <span class="n">fuzz</span><span class="o">.</span><span class="n">partial_ratio</span><span class="p">(</span><span class="n">text1</span><span class="p">,</span> <span class="n">text2</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">UnicodeDecodeError</span><span class="p">,</span> <span class="ne">UnicodeEncodeError</span><span class="p">):</span>
            <span class="n">partial_ratio</span> <span class="o">=</span> <span class="n">fuzz</span><span class="o">.</span><span class="n">partial_ratio</span><span class="p">(</span>
                <span class="n">_decode_text</span><span class="p">(</span><span class="n">text1</span><span class="p">,</span> <span class="n">throw_loud_fail</span><span class="p">),</span>
                <span class="n">_decode_text</span><span class="p">(</span><span class="n">text2</span><span class="p">,</span> <span class="n">throw_loud_fail</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">partial_ratio</span></div>


<span class="k">class</span> <span class="nc">SentenceTokenizer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">base_tokenizer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">regex_split_trailing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">regex_split_leading</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes a tokenizer that can be be used to break text into tokens using the `tokenize` function</span>

<span class="sd">        :param base_tokenizer: The tokenizer to use (default = NLTK&#39;s English Punkt tokenizer)</span>
<span class="sd">        :param regex_split_trailing: A compiled regex object used to define the end of sentences</span>
<span class="sd">        :param regex_split_leading: A compiled regex object used to define the beginning of sentences</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">base_tokenizer</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">base_tokenizer</span>
            <span class="k">if</span> <span class="n">base_tokenizer</span>
            <span class="k">else</span> <span class="n">nltk</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;tokenizers/punkt/english.pickle&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regex_split_trailing</span> <span class="o">=</span> <span class="n">regex_split_trailing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regex_split_leading</span> <span class="o">=</span> <span class="n">regex_split_leading</span>

    <span class="k">def</span> <span class="nf">tokenize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">throw_loud_fail</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">min_length</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param text: The text to tokenize</span>
<span class="sd">        :param throw_loud_fail: bool; whether or not to raise an error if text decoding fails (default=False)</span>
<span class="sd">        :param min_length: The minimum acceptable length of a sentence (if a token is shorter than this,</span>
<span class="sd">        it will be considered part of the preceding sentence)</span>
<span class="sd">        :return: A list of sentences</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">text</span> <span class="o">=</span> <span class="n">_decode_text</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">throw_loud_fail</span><span class="p">)</span>

        <span class="n">partial_tokens</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">token_group</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_tokenizer</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">regex_split_leading</span><span class="p">:</span>
                <span class="n">partial_tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">leaders</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">regex_split_leading</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="n">token_group</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">subt_lead</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">regex_split_leading</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">subt_lead</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                        <span class="n">token_group</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subt_lead</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">leaders</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">subt_lead</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">leaders</span><span class="p">:</span>
                        <span class="n">partial_tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">token_group</span><span class="p">))</span>
                        <span class="n">token_group</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">token_group</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">partial_tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">token_group</span> <span class="k">if</span> <span class="n">t</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">]))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">token_group</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">partial_tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">token_group</span> <span class="k">if</span> <span class="n">t</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">]))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">regex_split_trailing</span><span class="p">:</span>
            <span class="n">final_tokens</span> <span class="o">=</span> <span class="n">partial_tokens</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">final_tokens</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">token_group</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">partial_tokens</span><span class="p">:</span>
                <span class="n">trailers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">regex_split_trailing</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="n">token_group</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">subt_trail</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">regex_split_trailing</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">subt_trail</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                        <span class="n">token_group</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subt_trail</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">trailers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">subt_trail</span> <span class="ow">in</span> <span class="n">trailers</span><span class="p">:</span>
                        <span class="n">final_tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">token_group</span><span class="p">))</span>
                        <span class="n">token_group</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">token_group</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">final_tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">token_group</span> <span class="k">if</span> <span class="n">t</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">]))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">token_group</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">final_tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">token_group</span> <span class="k">if</span> <span class="n">t</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">]))</span>

        <span class="n">final_tokens</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">final_tokens</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">min_length</span><span class="p">:</span>
            <span class="n">final_tokens</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">final_tokens</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">min_length</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">final_tokens</span>


<span class="k">class</span> <span class="nc">TextOverlapExtractor</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokenizer</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A helper class designed to identify overlapping sections between two strings. </span>

<span class="sd">        :param tokenizer: The tokenizer to use (default = SentenceTokenizer())</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">tokenizer</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span> <span class="o">=</span> <span class="n">SentenceTokenizer</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span> <span class="o">=</span> <span class="n">tokenizer</span>

    <span class="k">def</span> <span class="nf">get_text_overlaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text1</span><span class="p">,</span> <span class="n">text2</span><span class="p">,</span> <span class="n">min_length</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">tokenize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extracts all overlapping segments of at least `min_length` characters between the two texts. If `tokenize=True`</span>
<span class="sd">        then only tokens that appear fully in both texts will be extracted. For example:</span>

<span class="sd">        ```python</span>
<span class="sd">        &gt;&gt;&gt; text1 = &quot;This is a sentence. This is another sentence. And a third sentence. And yet a fourth sentence.&quot;</span>
<span class="sd">        &gt;&gt;&gt; text2 = &quot;This is a different sentence. This is another sentence. And a third sentence. But the fourth sentence is different too.&quot;</span>
<span class="sd">        &gt;&gt;&gt; extractor = TextOverlapExtractor()</span>
<span class="sd">        &gt;&gt;&gt; extractor.get_text_overlaps(text1, text2, min_length=10, tokenize=False)</span>
<span class="sd">        [&#39; sentence. This is another sentence. And a third sentence. &#39;, &#39; fourth sentence&#39;]</span>
<span class="sd">        &gt;&gt;&gt; extractor.get_text_overlaps(text1, text2, min_length=10, tokenize=True)</span>
<span class="sd">        [&#39;This is another sentence.&#39;, &#39;And a third sentence.&#39;]</span>
<span class="sd">        ```</span>

<span class="sd">        :param text1: A piece of text</span>
<span class="sd">        :param text2: Another piece of text to compare against the first</span>
<span class="sd">        :param min_length: The minimum size of the overlap to be considered (number of characters)</span>
<span class="sd">        :param tokenize: If True, overlapping segments will only be included if they consist of atomic tokens; overlaps</span>
<span class="sd">        that consist of only part of a token will be excluded (default=True)</span>
<span class="sd">        :return: A list of all of the identified overlapping segments</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">tokenize</span><span class="p">:</span>
            <span class="n">valid_tokens</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">t</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="s2">&quot;. &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">text1</span><span class="p">,</span> <span class="n">text2</span><span class="p">]))</span>
            <span class="p">]</span>
        <span class="n">fragments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">SequenceMatcher</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">text1</span><span class="p">,</span> <span class="n">text2</span><span class="p">,</span> <span class="n">autojunk</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">get_matching_blocks</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">min_length</span><span class="p">:</span>
                <span class="n">overlap</span> <span class="o">=</span> <span class="n">text1</span><span class="p">[</span><span class="n">block</span><span class="o">.</span><span class="n">a</span> <span class="p">:</span> <span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">a</span> <span class="o">+</span> <span class="n">block</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
                <span class="k">if</span> <span class="n">tokenize</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span>
                        <span class="n">overlap</span><span class="p">,</span> <span class="n">min_length</span><span class="o">=</span><span class="n">min_length</span>
                    <span class="p">):</span>
                        <span class="n">token</span> <span class="o">=</span> <span class="n">token</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">valid_tokens</span><span class="p">:</span>
                            <span class="n">fragments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">overlap</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">min_length</span><span class="p">:</span>
                    <span class="n">fragments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">overlap</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fragments</span>

    <span class="k">def</span> <span class="nf">get_largest_overlap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text1</span><span class="p">,</span> <span class="n">text2</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the largest overlapping segment of text between the two texts (this doesn&#39;t use the tokenizer).</span>

<span class="sd">        :param text1: A piece of text</span>
<span class="sd">        :param text2: Another piece of text to compare against the first</span>
<span class="sd">        :return: The largest substring that occurs in both texts</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">s</span> <span class="o">=</span> <span class="n">SequenceMatcher</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">text1</span><span class="p">,</span> <span class="n">text2</span><span class="p">)</span>
        <span class="n">pos_a</span><span class="p">,</span> <span class="n">pos_b</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">find_longest_match</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">text1</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">text2</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">text1</span><span class="p">[</span><span class="n">pos_a</span> <span class="p">:</span> <span class="n">pos_a</span> <span class="o">+</span> <span class="n">size</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">TextCleaner</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">throw_loud_fail</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">filter_pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">process_method</span><span class="o">=</span><span class="s2">&quot;lemmatize&quot;</span><span class="p">,</span>
        <span class="n">processor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">lowercase</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">remove_urls</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">replacers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">stopwords</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">strip_html</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">tokenizer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A class for cleaning text up, in preparation for NLP, etc.  Attempts to decode the text.  Then lowercases,</span>
<span class="sd">        expands contractions, removes punctuation, lemmatizes or stems, removes stopwords and words less than three</span>
<span class="sd">        characters, and consolidates whitespace.</span>

<span class="sd">        :param lemmatize: Whether or not to lemmatize the tokens (default = True)</span>
<span class="sd">        :param tokenizer: Tokenizer to use (default = nltk.WhitespaceTokenizer())</span>
<span class="sd">        :param replacers: A list of tuples, each with a regex pattern followed by the string/pattern to replace them</span>
<span class="sd">        with. Anything passed here will be used in addition to a set of built-in replacement patterns for common</span>
<span class="sd">        contractions.</span>
<span class="sd">        :param process_method: Options are &quot;lemmatize&quot;, &quot;stem&quot;, or None (default = &quot;lemmatize&quot;)</span>
<span class="sd">        :param processor: A lemmatizer or stemmer with a &quot;lemmatize&quot; or &quot;stem&quot; function (default for</span>
<span class="sd">        process_method=&quot;lemmatize&quot; is nltk.WordNetLemmatizer(); default for process_method=&quot;stem&quot; is</span>
<span class="sd">        nltk.SnowballStemmer())</span>
<span class="sd">        :param stopwords: The set of stopwords to remove (default = nltk.corpus.stopwords.words(&#39;english&#39;))</span>
<span class="sd">        :param lowercase: Whether or not to lowercase the string (default = True)</span>
<span class="sd">        :param remove_urls: Whether or not to remove URLs and links from the text (default = True)</span>
<span class="sd">        :param throw_loud_fail: bool; whether or not to raise an error if text decoding fails (default=False)</span>
<span class="sd">        :param strip_html: Whether or not to remove contents wrapped in HTML tags (default = False)</span>
<span class="sd">        :param filter_pos: A list of WordNet parts-of-speech tags to keep;</span>
<span class="sd">        if provided, all other words will be removed (default = None)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span> <span class="o">=</span> <span class="n">tokenizer</span> <span class="k">if</span> <span class="n">tokenizer</span> <span class="k">else</span> <span class="n">nltk</span><span class="o">.</span><span class="n">WhitespaceTokenizer</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replacers</span> <span class="o">=</span> <span class="n">replacers</span> <span class="k">if</span> <span class="n">replacers</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replacers</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="p">(</span><span class="sa">r</span><span class="s2">&quot;won\&#39;t&quot;</span><span class="p">,</span> <span class="s2">&quot;will_not&quot;</span><span class="p">),</span>
                <span class="p">(</span><span class="sa">r</span><span class="s2">&quot;can\&#39;t&quot;</span><span class="p">,</span> <span class="s2">&quot;cannot&quot;</span><span class="p">),</span>
                <span class="p">(</span><span class="sa">r</span><span class="s2">&quot;i\&#39;m&quot;</span><span class="p">,</span> <span class="s2">&quot;i am&quot;</span><span class="p">),</span>
                <span class="p">(</span><span class="sa">r</span><span class="s2">&quot;ain\&#39;t&quot;</span><span class="p">,</span> <span class="s2">&quot;is not&quot;</span><span class="p">),</span>
                <span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w+)\&#39;ll&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\g&lt;1&gt; will&quot;</span><span class="p">),</span>
                <span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w+)n\&#39;t&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\g&lt;1&gt;_not&quot;</span><span class="p">),</span>
                <span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w+)\&#39;ve&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\g&lt;1&gt; have&quot;</span><span class="p">),</span>
                <span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w+)\&#39;re&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\g&lt;1&gt; are&quot;</span><span class="p">),</span>
                <span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w+)\&#39;d&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\g&lt;1&gt; would&quot;</span><span class="p">),</span>
                <span class="p">(</span><span class="sa">r</span><span class="s2">&quot;it\&#39;s&quot;</span><span class="p">,</span> <span class="s2">&quot;it is&quot;</span><span class="p">),</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replacers</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\b</span><span class="si">{}</span><span class="s2">\b&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">regex</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="n">regex</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">regex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">replacers</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="n">process_method</span> <span class="o">==</span> <span class="s2">&quot;lemmatize&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processor</span> <span class="o">=</span> <span class="n">processor</span> <span class="k">if</span> <span class="n">processor</span> <span class="k">else</span> <span class="n">nltk</span><span class="o">.</span><span class="n">WordNetLemmatizer</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processor</span><span class="o">.</span><span class="n">lemmatize</span>
        <span class="k">elif</span> <span class="n">process_method</span> <span class="o">==</span> <span class="s2">&quot;stem&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processor</span> <span class="o">=</span> <span class="n">processor</span> <span class="k">if</span> <span class="n">processor</span> <span class="k">else</span> <span class="n">nltk</span><span class="o">.</span><span class="n">SnowballStemmer</span><span class="p">(</span><span class="s2">&quot;english&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processor</span><span class="o">.</span><span class="n">stem</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processor</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_func</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">stopwords</span><span class="p">:</span>
            <span class="n">stopwords</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">nltk</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">stopwords</span><span class="o">.</span><span class="n">words</span><span class="p">(</span><span class="s2">&quot;english&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stopword_regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
            <span class="sa">r</span><span class="s2">&quot;\b(</span><span class="si">{}</span><span class="s2">)\b&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stopwords</span> <span class="k">if</span> <span class="n">s</span><span class="p">])),</span>
            <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">remove_urls</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">url_regex</span> <span class="o">=</span> <span class="n">URL_REGEX</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">url_regex</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">filter_pos</span> <span class="o">=</span> <span class="n">filter_pos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lowercase</span> <span class="o">=</span> <span class="n">lowercase</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">throw_loud_fail</span> <span class="o">=</span> <span class="n">throw_loud_fail</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strip_html</span> <span class="o">=</span> <span class="n">strip_html</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final_regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\w*\d\w*&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">clean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param string: The string to clean</span>
<span class="sd">        :return: The cleaned string</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># try to remove any html tags in the string</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strip_html</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">strip_html</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

        <span class="c1"># try to encode everything as utf-8</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">_decode_text</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">throw_loud_fail</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_pos</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">filter_parts_of_speech</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_pos</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lowercase</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">text</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">url_regex</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">url_regex</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">regex</span><span class="p">,</span> <span class="n">replace</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">replacers</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">regex</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">replace</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>  <span class="c1"># expand contractions</span>
        <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stopword_regex</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\W+&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>  <span class="c1"># remove punctuation</span>
        <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>  <span class="c1"># split on whitespace</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">processor</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">process_func</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">text</span><span class="p">]</span>

        <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">word</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">text</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">processor</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stopword_regex</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\W+&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>

        <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_regex</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">text</span>


<span class="k">class</span> <span class="nc">TextDataFrame</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">text_column</span><span class="p">,</span> <span class="o">**</span><span class="n">vectorizer_kwargs</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a class full of functions for working with dataframes of documents - it has utilities for identifying</span>
<span class="sd">        potential duplicates, identifying recurring segments of text, computing metrics like mutual information,</span>
<span class="sd">        extracting clusters of documents, and more. Given a DataFrame and the name of the column that contains the</span>
<span class="sd">        text to be analyzed, the TextDataFrame will automatically produce a TF-IDF sparse matrix representation of the</span>
<span class="sd">        text upon initialization. All other parameters are passed along to the scikit-learn TfidfVectorizer. For more</span>
<span class="sd">        info on the parameters it excepts, refer to the official documentation here:</span>
<span class="sd">        https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.TfidfVectorizer.html</span>

<span class="sd">        :param df: A dataframe of documents.  Must contain a column with text.</span>
<span class="sd">        :param text_column: The name of the column in the dataframe that contains the text</span>
<span class="sd">        :param vectorizer_kwargs: All remaining keyword arguments are passed to TfidfVectorizer</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span> <span class="o">=</span> <span class="n">df</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">text_column</span> <span class="o">=</span> <span class="n">text_column</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vectorizer</span> <span class="o">=</span> <span class="n">TfidfVectorizer</span><span class="p">(</span><span class="n">decode_error</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">vectorizer_kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tfidf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vectorizer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">text_column</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">search_corpus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compares the provided text against the documents in the corpus and returns the most similar documents.</span>
<span class="sd">        A new column called &#39;cosine_similarity&#39; is generated, which is used to sort and return the dataframe.</span>

<span class="sd">        :param text: The text to compare documents against</span>
<span class="sd">        :return: The corpus dataframe sorted by cosine similarity</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">similarities</span> <span class="o">=</span> <span class="n">cosine_similarity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vectorizer</span><span class="o">.</span><span class="n">transform</span><span class="p">([</span><span class="n">text</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfidf</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">[</span><span class="s2">&quot;search_cosine_similarity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">similarities</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;search_cosine_similarity&quot;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">match_text_to_corpus</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">match_list</span><span class="p">,</span> <span class="n">allow_multiple</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">min_similarity</span><span class="o">=</span><span class="mf">0.9</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes a list of text values and attempts to match them to the documents in the DataFrame. Each document will</span>
<span class="sd">        be matched to the value in the list to which it is most similar, based on cosine similarity.</span>

<span class="sd">        :param match_list: A list of strings (other documents) to be matched to documents in the dataframe</span>
<span class="sd">        :param allow_multiple: If set to True and your corpus contains duplicates, they will all be matched to</span>
<span class="sd">        their best match in match_list.  If False (default), only the first row will be matched.</span>
<span class="sd">        :param min_similarity: Minimum cosine similarity required for any match to be made.</span>
<span class="sd">        :return: Your corpus dataframe, with new columns match_text, match_index, and cosine_similarity</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">similarities</span> <span class="o">=</span> <span class="n">cosine_similarity</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tfidf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vectorizer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">match_list</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">[</span><span class="s2">&quot;match_text&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">[</span><span class="s2">&quot;match_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">[</span><span class="s2">&quot;cosine_similarity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">iterrows</span><span class="p">(),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Matching items to corpus&quot;</span><span class="p">):</span>
            <span class="n">row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">is_null</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;match_index&quot;</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sim</span> <span class="ow">in</span> <span class="p">[</span>
                    <span class="n">s</span>
                    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span>
                        <span class="nb">zip</span><span class="p">(</span>
                            <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">match_list</span><span class="p">))),</span>
                            <span class="n">similarities</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">index</span><span class="p">)],</span>
                        <span class="p">),</span>
                        <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">min_similarity</span>
                <span class="p">]:</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">[</span><span class="s2">&quot;match_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">allow_multiple</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">text_column</span><span class="p">]</span> <span class="o">==</span> <span class="n">row</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">text_column</span><span class="p">],</span>
                                <span class="s2">&quot;match_index&quot;</span><span class="p">,</span>
                            <span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">text_column</span><span class="p">]</span> <span class="o">==</span> <span class="n">row</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">text_column</span><span class="p">],</span>
                                <span class="s2">&quot;match_text&quot;</span><span class="p">,</span>
                            <span class="p">]</span> <span class="o">=</span> <span class="n">match_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">text_column</span><span class="p">]</span> <span class="o">==</span> <span class="n">row</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">text_column</span><span class="p">],</span>
                                <span class="s2">&quot;cosine_similarity&quot;</span><span class="p">,</span>
                            <span class="p">]</span> <span class="o">=</span> <span class="n">sim</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="s2">&quot;match_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="s2">&quot;match_text&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">match_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="s2">&quot;cosine_similarity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sim</span>
                        <span class="k">break</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span>

    <span class="k">def</span> <span class="nf">extract_corpus_fragments</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">scan_top_n_matches_per_doc</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">min_fragment_length</span><span class="o">=</span><span class="mi">15</span>
    <span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over the corpus dataframe and, for each document, scan the most similar other documents in the corpus.</span>
<span class="sd">        During each comparison, overlapping fragments are identified.  This can be useful for identifying common</span>
<span class="sd">        boilerplate sentences, repeated paragraphs, etc.</span>

<span class="sd">        :param scan_top_n_matches_per_doc: The number of other documents to compare each document against.</span>
<span class="sd">        :param min_fragment_length: The minimum character length a fragment must have to be extracted.</span>
<span class="sd">        :return: A list of fragments that were found.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">text_overlap_extractor</span> <span class="o">=</span> <span class="n">TextOverlapExtractor</span><span class="p">()</span>

        <span class="n">similarity_matrix</span> <span class="o">=</span> <span class="n">cosine_similarity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tfidf</span><span class="p">)</span>
        <span class="n">min_similarity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">similarity_matrix</span><span class="p">])</span>

        <span class="n">combos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">index</span><span class="p">)):</span>
            <span class="n">combos</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">cos_similarity</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">cos_similarity</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span>
                        <span class="nb">zip</span><span class="p">(</span>
                            <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">index</span><span class="p">))),</span>
                            <span class="n">similarity_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:],</span>
                        <span class="p">),</span>
                        <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">cos_similarity</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.997</span> <span class="ow">and</span> <span class="n">cos_similarity</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">min_similarity</span>
                <span class="p">][:</span><span class="n">scan_top_n_matches_per_doc</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="n">fragments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cos_similarity</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">combos</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Extracting fragments&quot;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">frag</span> <span class="ow">in</span> <span class="n">text_overlap_extractor</span><span class="o">.</span><span class="n">get_text_overlaps</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">text_column</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">cos_similarity</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">text_column</span><span class="p">],</span>
                <span class="n">min_length</span><span class="o">=</span><span class="n">min_fragment_length</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="n">frag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fragments</span><span class="p">:</span>
                    <span class="n">fragments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frag</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fragments</span>

    <span class="k">def</span> <span class="nf">find_duplicates</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">tfidf_threshold</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
        <span class="n">fuzzy_ratio_threshold</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span>
        <span class="n">allow_partial</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">max_partial_difference</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span>
        <span class="n">filter_function</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">partial_ratio_timeout</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
        <span class="n">decode_text</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Search for duplicates by using cosine similarity and Levenshtein ratios.  This will struggle with large</span>
<span class="sd">        corpora, so we recommend trying to filter down to potential duplicates first.  The corpus will first be</span>
<span class="sd">        scanned for document pairs with a cosine similarity greater or equal to the `tfidf_threshold`.  Then,</span>
<span class="sd">        each of these pairs will be compared using the more stringent `fuzzy_ratio_threshold`.</span>

<span class="sd">        :param tfidf_threshold: Minimum cosine similarity for two documents to be considered potential dupes.</span>
<span class="sd">        :param fuzzy_ratio_threshold: The required Levenshtein ratio to consider two documents duplicates.</span>
<span class="sd">        :param filter_function: An optional function that allows for more complex filtering.  The function must accept</span>
<span class="sd">        the following parameters: text1, text2, cosine_similarity, fuzzy_ratio.  Must return True or False, indicating</span>
<span class="sd">        whether the two documents should be considered duplicates.</span>
<span class="sd">        :return: A list of lists, containing groups of duplicate documents (represented as rows from the corpus</span>
<span class="sd">        dataframe)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">text_column</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">decode_text</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">_decode_text</span><span class="p">)</span>

        <span class="n">groups</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># compute cosine similarity between the inputs in tf.idf matrix</span>
        <span class="n">similarity_matrix</span> <span class="o">=</span> <span class="n">cosine_similarity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tfidf</span><span class="p">)</span>
        <span class="n">threshold_filter_matrix</span> <span class="o">=</span> <span class="n">similarity_matrix</span> <span class="o">&gt;=</span> <span class="n">tfidf_threshold</span>

        <span class="c1"># return the  location of the similarity matrix that satisfies the threshold</span>
        <span class="n">similarity_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">threshold_filter_matrix</span><span class="p">,</span> <span class="n">similarity_matrix</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># create pairs in the similarity matrix</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">similarity_matrix</span><span class="p">)</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">pairs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">similarity_matrix</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pairs</span> <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">pairs</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Scanning pairs&quot;</span><span class="p">):</span>
            <span class="n">sim</span> <span class="o">=</span> <span class="n">similarity_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
            <span class="n">ratio</span> <span class="o">=</span> <span class="n">get_fuzzy_ratio</span><span class="p">(</span><span class="n">text</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">text</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">ratio</span> <span class="o">&lt;</span> <span class="n">fuzzy_ratio_threshold</span> <span class="ow">and</span> <span class="n">allow_partial</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">partial_ratio</span> <span class="o">=</span> <span class="n">get_fuzzy_partial_ratio</span><span class="p">(</span>
                        <span class="n">text</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">text</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">timeout</span><span class="o">=</span><span class="n">partial_ratio_timeout</span>
                    <span class="p">)</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">MemoryError</span><span class="p">,</span> <span class="n">TimeoutException</span><span class="p">):</span>
                    <span class="n">partial_ratio</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                    <span class="n">partial_ratio</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">partial_ratio</span>
                    <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ratio</span> <span class="o">-</span> <span class="n">partial_ratio</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">max_partial_difference</span>
                <span class="p">):</span>
                    <span class="n">ratio</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">ratio</span><span class="p">,</span> <span class="n">partial_ratio</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">ratio</span> <span class="o">&gt;=</span> <span class="n">fuzzy_ratio_threshold</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="ow">not</span> <span class="n">filter_function</span>
                <span class="ow">or</span> <span class="n">filter_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">sim</span><span class="p">,</span> <span class="n">ratio</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">groups</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="ow">and</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">groups</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                    <span class="n">new_group</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
                    <span class="n">groups</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_group</span>
                    <span class="n">groups</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_group</span>
                <span class="k">elif</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">groups</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="ow">and</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">groups</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                    <span class="n">groups</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">groups</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">groups</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="ow">and</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">groups</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                    <span class="n">groups</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">groups</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">groups</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                    <span class="n">groups</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="n">duplicates</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">final_groups</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">groups</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">g</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">final_groups</span><span class="p">:</span>
                <span class="n">final_groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
                <span class="n">duplicates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="p">)])</span>

        <span class="k">return</span> <span class="n">duplicates</span>

    <span class="k">def</span> <span class="nf">mutual_info</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">outcome_col</span><span class="p">,</span> <span class="n">weight_col</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sample_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A wrapper around `pewanalytics.stats.mutual_info.compute_mutual_info`</span>

<span class="sd">        :param outcome_col: The name of the column with the binary outcome variable</span>
<span class="sd">        :param weight_col: (Optional) Name of the column to use in weighting</span>
<span class="sd">        :param l: An optional Laplace smoothing parameter</span>
<span class="sd">        :param normalize: Toggle normalization on or off (to control for feature prevalence), on by default</span>
<span class="sd">        :return: A DataFrame of ngrams and various metrics about them, including mutual information</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">sample_size</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">sample_size</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span>
        <span class="k">if</span> <span class="n">weight_col</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span>
                <span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">text_column</span><span class="p">,</span> <span class="n">outcome_col</span><span class="p">,</span> <span class="n">weight_col</span><span class="p">]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">text_column</span><span class="p">,</span> <span class="n">outcome_col</span><span class="p">])</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">outcome_col</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vectorizer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">text_column</span><span class="p">])</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">weight_col</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">weight_col</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">compute_mutual_info</span><span class="p">(</span>
            <span class="n">y</span><span class="p">,</span>
            <span class="n">x</span><span class="p">,</span>
            <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span>
            <span class="n">col_names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vectorizer</span><span class="o">.</span><span class="n">get_feature_names</span><span class="p">(),</span>
            <span class="n">l</span><span class="o">=</span><span class="n">l</span><span class="p">,</span>
            <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">kmeans_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A wrapper around `pewanalytics.stats.clustering.compute_kmeans_clusters`. Will compute clusters of documents.</span>
<span class="sd">        The resulting cluster IDs for each document are saved in the TextDataFrame&#39;s `corpus` in a new column called</span>
<span class="sd">        &quot;kmeans&quot;.</span>

<span class="sd">        :param k: The number of clusters to extract</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">[</span><span class="s2">&quot;kmeans&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">compute_kmeans_clusters</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tfidf</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">return_score</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;KMeans clusters saved to self.corpus[&#39;kmeans&#39;]&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">hdbscan_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_cluster_size</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A wrapper around `pewanalytics.stats.clustering.compute_hdbscan_clusters`. Will compute clusters of documents.</span>
<span class="sd">        The resulting cluster IDs for each document are saved in the TextDataFrame&#39;s `corpus` in a new column called</span>
<span class="sd">        &quot;hdbscan&quot;.</span>

<span class="sd">        :param min_cluster_size: The minimum number of documents that a cluster must contain.</span>
<span class="sd">        :param min_samples: An HDBSCAN parameter; refer to the documentation for more information</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">[</span><span class="s2">&quot;hdbscan&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">compute_hdbscan_clusters</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tfidf</span><span class="p">,</span> <span class="n">min_cluster_size</span><span class="o">=</span><span class="n">min_cluster_size</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="n">min_samples</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;HDBSCAN clusters saved to self.corpus[&#39;hdbscan&#39;]&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">top_cluster_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster_col</span><span class="p">,</span> <span class="n">min_size</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">top_n</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extracts the top terms for each cluster, based on a column of cluster IDs saved to `self.corpus`, using</span>
<span class="sd">        mutual information. Returns the `top_n` terms for each cluster.</span>

<span class="sd">        :param cluster_col: The name of the column that contains the document cluster IDs</span>
<span class="sd">        :param min_size: Ignore clusters that have fewer than this number of documents</span>
<span class="sd">        :param top_n: The number of top terms to identify for each cluster</span>
<span class="sd">        :return: A dictionary; keys are the cluster IDs and values are the top terms for the cluster</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">dummies</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">get_dummies</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">[</span><span class="n">cluster_col</span><span class="p">],</span> <span class="n">prefix</span><span class="o">=</span><span class="n">cluster_col</span><span class="p">)</span>
        <span class="n">cluster_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">,</span> <span class="n">dummies</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">terms</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">cluster_df</span><span class="p">[</span><span class="n">cluster_col</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">is_not_null</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_df</span><span class="p">[</span><span class="n">cluster_df</span><span class="p">[</span><span class="n">cluster_col</span><span class="p">]</span> <span class="o">==</span> <span class="n">cluster</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="n">min_size</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cluster_col</span><span class="p">,</span> <span class="n">cluster</span><span class="p">)]</span> <span class="o">=</span> <span class="n">cluster_df</span><span class="p">[</span>
                    <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cluster_col</span><span class="p">,</span> <span class="n">cluster</span><span class="p">)</span>
                <span class="p">]</span>
                <span class="n">minfo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mutual_info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cluster_col</span><span class="p">,</span> <span class="n">cluster</span><span class="p">))</span>
                <span class="n">minfo</span> <span class="o">=</span> <span class="n">minfo</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;MI1&quot;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)[:</span><span class="n">top_n</span><span class="p">]</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cluster_col</span><span class="p">,</span> <span class="n">cluster</span><span class="p">)]</span>
                <span class="n">minfo</span> <span class="o">=</span> <span class="n">minfo</span><span class="p">[</span><span class="n">minfo</span><span class="p">[</span><span class="s2">&quot;MI1&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;MI1&quot;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span>
                    <span class="p">:</span><span class="n">top_n</span>
                <span class="p">]</span>
                <span class="n">terms</span><span class="p">[</span><span class="n">cluster</span><span class="p">]</span> <span class="o">=</span> <span class="n">minfo</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;Cluster #</span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2"> documents: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">cluster</span><span class="p">,</span>
                        <span class="nb">len</span><span class="p">(</span><span class="n">cluster_df</span><span class="p">[</span><span class="n">cluster_df</span><span class="p">[</span><span class="n">cluster_col</span><span class="p">]</span> <span class="o">==</span> <span class="n">cluster</span><span class="p">]),</span>
                        <span class="n">minfo</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">terms</span>

    <span class="k">def</span> <span class="nf">pca_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A wrapper around `pewanalytics.stats.dimensionality_reduction.get_pca`.</span>
<span class="sd">        Saves the PCA components to self.corpus as new columns (&#39;pca_1&#39;, &#39;pca_2&#39;, etc.),</span>
<span class="sd">        saves the top component for each document as self.corpus[&#39;pca&#39;], and returns</span>
<span class="sd">        the features-component matrix.</span>

<span class="sd">        :param k: Number of dimensions to extract</span>
<span class="sd">        :return: A dataframe of (features x components)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">components</span><span class="p">,</span> <span class="n">documents</span> <span class="o">=</span> <span class="n">get_pca</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tfidf</span><span class="p">,</span> <span class="n">feature_names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vectorizer</span><span class="o">.</span><span class="n">get_feature_names</span><span class="p">(),</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">documents</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">documents</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Top PCA dimensions saved as clusters to self.corpus[&#39;pca&#39;]&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">components</span>

    <span class="k">def</span> <span class="nf">lsa_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A wrapper around `pewanalytics.stats.dimensionality_reduction.get_lsa`.</span>
<span class="sd">        Saves the LSA components to self.corpus as new columns (&#39;lsa_1&#39;, &#39;lsa_2&#39;, etc.),</span>
<span class="sd">        saves the top component for each document as self.corpus[&#39;lsa&#39;], and returns</span>
<span class="sd">        the features-component matrix</span>

<span class="sd">        :param k: Number of dimensions to extract</span>
<span class="sd">        :return: A dataframe of (features x components)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">components</span><span class="p">,</span> <span class="n">documents</span> <span class="o">=</span> <span class="n">get_lsa</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tfidf</span><span class="p">,</span> <span class="n">feature_names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vectorizer</span><span class="o">.</span><span class="n">get_feature_names</span><span class="p">(),</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">documents</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">documents</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Top LSA dimensions saved as clusters to self.corpus[&#39;lsa&#39;]&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">components</span>

    <span class="k">def</span> <span class="nf">get_top_documents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component_prefix</span><span class="o">=</span><span class="s2">&quot;cluster&quot;</span><span class="p">,</span> <span class="n">top_n</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use after running `get_pca_components` or `get_lsa_components`. Returns the `top_n` documents with the highest</span>
<span class="sd">        scores for each components.</span>

<span class="sd">        :param component_prefix: &#39;lsa&#39; or &#39;pca&#39; (you must first run get_pca_components or get_lsa_components)</span>
<span class="sd">        :param top_n: Number of documents to return for each component</span>
<span class="sd">        :return: A dictionary where keys are the component, and values are the text values for the component&#39;s `top_n`</span>
<span class="sd">        documents</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">top_docs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="p">[</span>
            <span class="n">c</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">columns</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">component_prefix</span><span class="p">))</span>
        <span class="p">]:</span>
            <span class="n">docs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">[</span><span class="n">component_prefix</span><span class="p">]</span> <span class="o">==</span> <span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span>
                <span class="n">col</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)[:</span><span class="n">top_n</span><span class="p">]</span>
            <span class="n">top_docs</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">docs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">text_column</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="k">return</span> <span class="n">top_docs</span>

    <span class="k">def</span> <span class="nf">make_word_cooccurrence_matrix</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">min_frequency</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">max_frequency</span><span class="o">=</span><span class="mf">0.5</span>
    <span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use to produce word co-occurrence matrices. Based on a helpful StackOverflow post:</span>
<span class="sd">        https://stackoverflow.com/questions/35562789/how-do-i-calculate-a-word-word-co-occurrence-matrix-with-sklearn</span>

<span class="sd">        :param normalize: If True, will be normalized</span>
<span class="sd">        :param min_frequency: The minimum document frequency required for a term to be included</span>
<span class="sd">        :param max_frequency: The maximum proportion of documents containing a term allowed to include the term</span>
<span class="sd">        :return: A matrix of (terms x terms) whose values indicate the number of documents in which two terms</span>
<span class="sd">        co-occurred</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">text_column</span><span class="p">]</span>
        <span class="n">cv</span> <span class="o">=</span> <span class="n">CountVectorizer</span><span class="p">(</span>
            <span class="n">ngram_range</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">stop_words</span><span class="o">=</span><span class="s2">&quot;english&quot;</span><span class="p">,</span>
            <span class="n">min_df</span><span class="o">=</span><span class="n">min_frequency</span><span class="p">,</span>
            <span class="n">max_df</span><span class="o">=</span><span class="n">max_frequency</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="n">mat</span><span class="p">[</span>
            <span class="n">mat</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mi">1</span>
        <span class="p">)</span>  <span class="c1"># this makes sure that we&#39;re counting number of documents words have in common \</span>
        <span class="c1"># and not weighting by the frequency of one of the words in a single document, which can lead to spurious links</span>
        <span class="n">names</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">get_feature_names</span><span class="p">()</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">mat</span>  <span class="c1"># compute the document-document matrix</span>
        <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
            <span class="n">diag</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">mat</span><span class="o">.</span><span class="n">diagonal</span><span class="p">())</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">diag</span> <span class="o">*</span> <span class="n">mat</span>
        <span class="n">mat</span><span class="o">.</span><span class="n">setdiag</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">mat</span><span class="o">.</span><span class="n">todense</span><span class="p">(),</span> <span class="n">columns</span><span class="o">=</span><span class="n">names</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">names</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">matrix</span>

    <span class="k">def</span> <span class="nf">make_document_cooccurrence_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use to produce document co-occurrence matrices. Based on a helpful StackOverflow post:</span>
<span class="sd">        https://stackoverflow.com/questions/35562789/how-do-i-calculate-a-word-word-co-occurrence-matrix-with-sklearn</span>

<span class="sd">        :param normalize: If True, will be normalized</span>
<span class="sd">        :return: A matrix of (documents x documents) whose values indicate the number of terms they had in common</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">text_column</span><span class="p">]</span>
        <span class="n">cv</span> <span class="o">=</span> <span class="n">CountVectorizer</span><span class="p">(</span><span class="n">ngram_range</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">stop_words</span><span class="o">=</span><span class="s2">&quot;english&quot;</span><span class="p">)</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="n">mat</span><span class="p">[</span>
            <span class="n">mat</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mi">1</span>
        <span class="p">)</span>  <span class="c1"># this makes sure that we&#39;re counting number of words documents have in common \</span>
        <span class="c1"># and not weighting by the frequency of one of the words in a single document, which can lead to spurious links</span>
        <span class="n">names</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">index</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span> <span class="o">*</span> <span class="n">mat</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># compute the word-word matrix</span>
        <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
            <span class="n">diag</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">mat</span><span class="o">.</span><span class="n">diagonal</span><span class="p">())</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">diag</span> <span class="o">*</span> <span class="n">mat</span>
        <span class="n">mat</span><span class="o">.</span><span class="n">setdiag</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">mat</span><span class="o">.</span><span class="n">todense</span><span class="p">(),</span> <span class="n">columns</span><span class="o">=</span><span class="n">names</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">names</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">matrix</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">pewanalytics</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Navigation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../text.html">Text</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stats.html">Stats</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Pew Research Center.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>